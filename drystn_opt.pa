/PDP-12 DHRYSTONE BY ZACHARY KIRTZ
/BASED ON DHRYSTONE BY REINHOLD P. WEICKER

/EAE INSTRUCTIONS
MUY=7405
DVI=7407
SHL=7413

/KW12-A CLOCK INSTRUCTIONS
CLLR=6132
CLEN=6134
CLSA=6135
CLCA=6137

/IDENT VALUES
ID1=0
ID2=1
ID3=2
ID4=3
ID5=4

/MISC DEFS
RECSZ=25	/RECORD STRUCT SIZE
STRSZ=21	/STR_30 SIZE
ARRDIM=62	/ARRAY DIMS
DEFDF=00	/DEFAULT DATA FIELD
STRDF=10	/STRING DATA FIELD

*20
/FIELD 0 GLOBAL VARIABLES
GINT,	0	/INT_GLOB
GBOOL,	0	/BOOL_GLOB
GCH1,	0	/CH_1_GLOB
GCH2,	0	/CH_2_GLOB

/GLOBAL VARIABLE ADDRESSES
GPTR,	GREC	/PTR_GLOB
GNPTR,	GNREC	/NEXT_PTR_GLOB
KGINT,	GINT
KGBOOL,	GBOOL
KGCH1,	GCH1
KGCH2,	GCH2
KGARR,	GARR
KGARR2,	GARR2

/GLOBAL CONSTANTS
IDENT1,	ID1
IDENT2,	ID2
IDENT3,	ID3
IDENT4,	ID4
IDENT5,	ID5
RUNCNT,	7700	/RUN COUNT

/MAIN LOCAL VARIABLES
/PUTTING THESE IN PZ AT LEAST FOR NOW SINCE
/IT MAKES MY LIFE EASIER, WE HAVE SPACE, AND
/IT SHOULDN'T IMPACT PERFORMANCE
MINT1,	0	/INT_1_LOC
MINT2,	0	/INT_2_LOC
MINT3,	0	/INT_3_LOC
MENUM,	0	/ENUM_LOC
MRIDX,	0	/RUN_INDEX

/MAIN PROGRAM LOCAL VARIABLE POINTERS
KMINT1,	MINT1	/INT_1_LOC PTR
KMINT3,	MINT3	/INT_3_LOC PTR
KMENUM,	MENUM	/ENUM_LOC PTR
KMSTR1,	MSTR1	/STR_1_LOC PTR
KMSTR2,	MSTR2	/STR_2_LOC PTR
/THIS PAGE CONTAINS
/MAIN FUNCTION BEGINING AND ENDING

PAGE

/LOCAL VARIABLES
MTIMER,	0		/TIMER

/MAIN START
	CLA
			/SET ARR2[8][7]=10
	TAD (ARRDIM^10+7
	HLT
	TAD KGARR2
	DCA 1
	TAD (12
	DCA I 1
	JMS PUTMSG	/PRINT BEGIN MSG
	PRSTRT
	TAD RUNCNT	/PRINT RUN COUNT
	JMS PUTMSI
	PRRCT
	CLLR		/CLEAR KW12 MODES
	CLEN		/CLEAR KW12 ENABLES
	TAD (0100	/SET TO MODE1, CLEAR COUNTER
	CLLR
	CLSA		/CLEAR KW12 EVENTS
	CLA
	TAD (5000	/SWITCH KW12 TO 100HZ MODE 0
	CLLR
	JMP MLOOP	/JUMP TO MAIN LOOP
			/MAIN LOOP RETURNS HERE
			/PRINT END RESULTS
MNEND,	CLCA		/GET KW12 COUNTER
	DCA MTIMER	/SAVE FOR LATER
	CLLR		/STOP KW12
	JMS PUTMSG	/END MESSAGE
	PREND
	TAD MTIMER	/PRINT TIME
	JMS PUTMSI
	PRTIME
	TAD GINT	/INT_GLOB MSG
	JMS PUTMSI
	PRGINT
	TAD GBOOL	/BOOL_GLOB MSG
	JMS PUTMSI
	PRGBOOL
	TAD GCH1	/CH_1_GLOB MSG
	JMS PUTMSI
	PRGCH1
	TAD GCH2	/CH_2_GLOB MSG
	JMS PUTMSI
	PRGCH2
	TAD KGARR	/ARR_1_GLOB MSG; GET ARR[8]
	TAD (10
	DCA 1
	TAD I 1		/LOAD ARR[8]
	JMS PUTMSI
	PRARR1
			/ARR_2_GLOB MSG; GET ARR2[8][7]
	TAD (ARRDIM^10+7
	TAD KGARR2
	DCA 1
	TAD I 1		/LOAD ARR[8][7]
	JMS PUTMSI
	PRARR2
	TAD GPTR	/PTR_GLOB MSG
	JMS PUTMSI
	PRPTR
	TAD GPTR	/PRINT GPTR CONTENTS
	JMS PUTREC
	TAD GNPTR	/NEXT_PTR_GLOB MSG
	JMS PUTMSI
	PRNPTR
	TAD GNPTR	/PRINT GNPTR CONTENTS
	JMS PUTREC
	TAD MINT1	/INT_1_LOC MSG
	JMS PUTMSI
	PRLIT1
	TAD MINT2	/INT_2_LOC MSG
	JMS PUTMSI
	PRLIT2
	TAD MINT3	/INT_3_LOC MSG
	JMS PUTMSI
	PRLIT3
	TAD MENUM	/ENUM_LOC MSG
	JMS PUTMSI
	PRLENM
	TAD KMSTR1	/STR_1_LOC MSG
	JMS PUTMSS
	PRLST1
	TAD KMSTR2	/STR_2_LOC MSG
	JMS PUTMSS
	PRLST2
	JMP I KEXIT	/RETURN TO OS/8 MONITOR


TEXTST,	TEXT \(TESTSTRING!123456HELLO:)\
KTEXTS,	TEXTST

KEXIT,	7600

/THIS PAGE CONTAINS:
/MAIN FUNCTION LOOP

PAGE

/MAIN LOOP CONSTANTS
DPSTR2,	TEXT \DHRYSTONE PROGRAM, 2'ND STRING\
DPSTR3, TEXT \DHRYSTONE PROGRAM, 3'RD STRING\
KDPST2,	DPSTR2
KDPST3,	DPSTR3

/MAIN LOOP
MLOOP,	CLA		/SET ROUND COUNTER TO 0
	DCA MRIDX
MLPSRT,	TAD MRIDX	/CHECK RIDX!=RUNCNT
	CIA
	TAD RUNCNT
	SNA		/BREAK IF NOT
	JMP MNEND	/JUMP TO END
	JMS PROC5	/CALL PROC5
	JMS PROC4	/CALL PROC4
	TAD (2		/MINT1 = 2
	DCA MINT1
	TAD (3		/MINT2 = 3
	DCA MINT2
	TAD KDPST2	/COPY DPSTR2 TO MSTR2
	MQL		/USING STRCPY
	TAD KMSTR2
	JMS STRCPY
	CLA IAC		/SET MENUM TO IDENT2 (1)
	DCA MENUM
	TAD KMSTR2	/CALL FUNC2 WITH STR1,STR2
	MQL
	TAD KMSTR1
	JMS FUNC2
	CMA		/INVERT THE RESULT
	AND (1		/AND SAVE IT TO GBOOL
	DCA GBOOL
	JMS MLPL1	/RUN FIRST LOOP
	TAD KGARR2	/PUT ARR2 ADDR IN PARAM[3]
	DCA 3
	TAD KGARR	/PUT ARR ADDR IN PARAM[2]
	DCA 2
	TAD MINT3	/PUT MINT3 IN PARAM[1]
	DCA 1
	TAD MINT1	/PUT MINT1 IN PARAM[AC]
	JMS PROC8	/CALL PROC8
	TAD GPTR	/CALL PROC1 WITH GPTR
	JMS PROC1
	JMS MLPL2	/PERFORM SECOND SUB LOOP
	TAD MINT1	/MINT2=MINT2*MINT1
	MQL
	TAD MINT2
	DCA .+2
	MUY
	0		/MULTIPLY OPERAND
	CLA MQA
	DCA MINT2
	TAD MINT3	/MINT1=MINT2/MINT3
	DCA .+2
	DVI
	0		/DIV OPERAND
	CLA MQA
	DCA MINT1	/SAVE IT
	TAD MINT3	/MINT2=7*(MINT2-MINT3)-MINT1
	CIA		/MINT2-MINT3
	TAD MINT2
	MQL		/MUL BY 7
	MUY
	7
	CLA MQA		/-(MINT1-X)==X-MINT1
	CIA
	TAD MINT1
	CIA
	DCA MINT2	/SAVE IT
	TAD KMINT1	/CALL PROC2 WITH MINT1 ADDR
	JMS PROC2
	ISZ MRIDX	/INCREMENT RUN INDEX
	JMP MLPSRT	/LOOP BACK AROUND

/THIS PAGE CONTAINS
/MAIN LOOP SUB LOOP ROUTINES
/MLPL1 & MLPL2

PAGE

/MAIN LOOP FIRST SUB LOOP
MLPL1,	0
	CLA
	TAD MINT2	/CHECK MINT1<MINT2
	CIA
	TAD MINT1
	SMA		/YES IF NEGATIVE
	JMP MLPL1E	/JUMP TO LOOP END IF NO
	CLA
	TAD MINT1	/MUL MINT1 BY 5
	CLL RTL		/FIRST BY 4
	TAD MINT1	/ADD ANOTHER
	DCA 1
	TAD MINT2	/SUB MINT2 FROM IT
	CIA
	TAD 1
	DCA MINT3	/SET MINT3 TO THE RESULT
	TAD KMINT3	/LOAD MINT3 ADDR AS PARAM[2]
	DCA 2
	TAD MINT2	/LOAD MINT2 AS PARAM[1]
	DCA 1
	TAD MINT1	/LOAD MINT1 AS PARAM[AC]
	JMS PROC7	/CALL PROC7
	ISZ MINT1	/INCREMENT MINT1
	JMP MLPL1+1	/LOOP BACK AROUND
MLPL1E,	CLA		/CLEAR AC FOR CALLER
	JMP I MLPL1	/RETURN

/MAIN LOOP SECOND SUB LOOP
MLPL2I,	0	/LOOP INDEX
MLPL2,	0
	CLA
	TAD (1		/SET INDEX TO 'A' (1)
	DCA MLPL2I
MLPL2S,	CLA
	TAD MLPL2I	/CHECK INDEX<=GCH2
	CIA
	TAD GCH2
	SPA		/BREAK OUT IF NOT
	JMP MLPL2E
	CLA
	TAD (3		/PUT 'C' (3) IN PARAM[1]
	DCA 1
	TAD MLPL2I	/PUT INDEX IN PARAM[AC]
	JMS FUNC1	/CALL FUNC1
	CIA		/CHECK IF RESULT==MENUM
	TAD MENUM
	SZA		/LOOP BACK IF NOT
	JMP MLPL2L	/LOOP BACK IF NOT
	TAD KMENUM	/PUT MENUM ADDR IN PARAM[1]
	DCA 1
	/TAD IDENT1	/PUT IDENT1 IN PARAM[AC]
	JMS PROC6	/CALL PROC6
	TAD KDPST3	/COPY DPSTR3 TO MSTR2
	MQL
	TAD KMSTR2
	JMS STRCPY
	TAD MRIDX	/SET MINT2 & GINT TO INDEX
	DCA MINT2
	TAD MRIDX
	DCA GINT
MLPL2L,	ISZ MLPL2I	/INCREMENT INDEX
	JMP MLPL2S	/LOOP BACK AROUND
MLPL2E,	CLA		/CLEAR AC FOR CALLER
	JMP I MLPL2	/RETURN
/THIS PAGE CONTAINS:
/CHRCMP, STRCMP
/MEMCPY, STRCPY
PAGE

/CHARACTER COMPARE FUNCTION
/PARAM[AC]	FIRST CHAR
/PARAM[MQ]	SECOND CHAR
/RESULT[AC]	DIFFERENCE
CHRCMP,	0
	AND (77		/ONLY WANT 2ND HALF
	DCA 7		/STORE IN SCRATCH
	MQA		/LOAD 2ND CHR INTO AC
	AND (77		/ONLY WANT 2ND HALF
	CIA		/NEGATE 2ND CHR
	TAD 7		/SUB 2ND FROM 1ST
	JMP I CHRCMP

/STRING COMPARE FUNCTION
/PARAM[AC]	FIRST STRING
/PARAM[1]	SECOND STRING
/RESULT[AC]	DIFFERENCE
SCMPS1=2		/FIRST STRING
SCMPS2=1		/SECOND STRING
STRCMP,	0
	DCA SCMPS1	/STORE 1ST TO SCRATCH
SCMPLP,	TAD I SCMPS2	/LOAD 1ST HALF OF 2ND STR
	RTR;RTR;RTR
	MQL
	TAD I SCMPS1	/LOAD 1ST HALF OF 1ST STR
	RTR;RTR;RTR
	JMS CHRCMP	/COMPARE CHARS
	SZA		/RETURN IF DIFF
	JMP I STRCMP
	TAD I SCMPS2	/LOAD 2ND HALF OF 2ND STR
	MQL
	TAD I SCMPS1	/LOAD 2ND HALF OF 1ST STR
	JMS CHRCMP	/COMPARE CHARS
	SZA		/RETURN IF DIFF
	JMP I STRCMP
	MQL MQA		/CHECK IF 2ND HALF IS ZERO
	SNA		/RETURN IF IT IS
	JMP SCMPRE
	ISZ SCMPS1	/INCREMENT STR PTRS
	ISZ SCMPS2
	CLA
	JMP SCMPLP	/LOOP BACK
SCMPRE,	CLA MQA		/COPY CMP RES BACK TO AC
	JMP I STRCMP

/STRING COPY FUNCTION
/PARAM[AC]	DST
/PARAM[MQ]	SRC
SCPYSR=11		/SOURCE ADDRESS
SCPYDS=10		/DESTINATION ADDRESS
STRCPY,	0
	TAD (-1		/SUB 1 FROM EACH
	DCA 10		/AND PUT IN AUTOIDX
	MQA
	TAD (-1
	DCA 11
SCPYLP,	TAD I 11	/LOAD A WORD
	MQL		/SAVE FOR LATER
	MQA
	DCA I 10	/SAVE AT DST
	MQA
	AND (77		/CHECK IF 2ND HALF IS ZERO
	SNA		/RETURN IF IT IS
	JMP SCPYEN	/JUMP TO END
	CLA		/CLEAR AC FOR NEXT LOOP
	JMP SCPYLP	/OTHERWISE, LOOP AGAIN
SCPYEN,	CLA		/CLEAR AC FOR CALLER
	JMP I STRCPY	/RETURN

/MEMORY COPY FUNCTION
/PARAM[AC]	DST
/PARAM[MQ]	SRC
/PARAM[1]	LENGTH
MCPYLN=1		/LENGTH
MCPYDS=10		/SOURCE ADDRESS
MCPYSR=11		/DESTINATION ADDRESS
MEMCPY,	0
	TAD (-1		/SUB 1 FROM EACH
	DCA MCPYDS	/AND PUT IN AUTOIDX
	MQA
	TAD (-1
	DCA MCPYSR
	TAD MCPYLN	/NEGATE LENGTH, SUB 1
	CMA
	DCA MCPYLN
MCPYLP,	ISZ MCPYLN	/INC COUNT, CHECK IF DONE
	JMP .+2		/SKIP RETURN
	JMP MCPYEN	/JUMP TO END
	TAD I MCPYSR	/READ A WORD
	DCA I MCPYDS	/SAVE TO DST
	JMP MCPYLP	/LOOP BACK AROUND
MCPYEN,	CLA		/CLEAR AC FOR CALLER
	JMP I MEMCPY	/RETURN

/THIS PAGE CONTAINS:
/PUTC, PUTCHR, PUTSTR
/PUTOCT, PUTNL, PUTMSG
/PUTMSI, PUTMSS, PUTREC

PAGE

/PRINT CHAR IMPLEMENTATION
/PARAM[AC]	CHAR
/RESULT[AC]	UNCHANGED
PUTC,	0
	TLS		/SEND CHAR
	TSF		/WAIT FOR PRINT FINISH
	JMP .-1
	JMP I PUTC	/RETURN

/PRINT CHARACTER FUNCTION
/PARAM[AC]	CHARACTER
/RESULT[AC]	8BIT CHAR
PUTCHR,	0
	AND (77		/ONLY WANT 1ST HALF
	SNA		/RETURN IF ZERO
	JMP I PUTCHR
	TAD (-40	/CONVERT FROM 6BIT
	SPA		/ASCII TO 8BIT ASCII
	TAD (100	/(ALPHA CHAR)
	TAD (240
	JMS PUTC	/ACTUALLY SEND CHAR
	JMP I PUTCHR

/PRINT STRING FUNCTION
/PARAM[AC]	STRING ADDRESS
PUTSTR,	0
	TAD (-1		/PLACE ADDR-1 IN AUTOIDX
	DCA 10
PSTRLP,	TAD I 10	/GET CHAR
	MQL		/SAVE FOR LATER
	MQA
	RTR;RTR;RTR	/GET FIRST HALF
	JMS PUTCHR	/PRINT CHR
	SNA		/RETURN IF ZERO
	JMP I PUTSTR	/(NULL CHR WAS PROVIDED)
	CLA MQA		/GET 2ND HALF
	JMS PUTCHR	/PRINT CHR
	SNA		/RETURN IF ZERO
	JMP I PUTSTR
	CLA		/CLEAR AC FOR NEXT LOOP
	JMP PSTRLP	/LOOP BACK AROUND

/PRINT OCTAL NUMBER
/PARAM[AC]	NUMBER TO PRINT
POCTCT,	0		/PRINTED COUNT
PUTOCT,	0
	MQL		/PUT NUMBER IN MQ
	TAD (-4		/SET COUNTER TO -4
	DCA POCTCT
POCTLP,	CLA SHL		/SHIFT NEXT BITS INTO AC
	0002
	TAD (60		/ADD '0' TO GET ASCII CHAR
	JMS PUTCHR	/PRINT CHAR
	ISZ POCTCT	/CHECK HOW MANY LEFT
	JMP POCTLP	/LOOP BACK AROUND
	CLA		/CLEAR AC FOR CALLER
	JMP I PUTOCT	/RETURN

/SEND NEWLINE CHARACTER
PUTNL,	0
	CLA
	TAD (215	/PRINT CR
	JMS PUTC
	CLA
	TAD (212	/SEND LF
	JMS PUTC
	CLA		/CLEAR AC FOR CALLER
	JMP I PUTNL	/RETURN

/PRINT A MESSAGE
/PARAM[CALL+1]	MESSAGE INDEX
PUTMSG,	0
	CLA
	TAD I PUTMSG	/GET STR ADDR
	CDF STRDF	/SWITCH TO STR DATA FIELD
	JMS PUTSTR	/PRINT STRING
	CDF DEFDF	/SWITCH BACK TO DEF DF
	JMS PUTNL	/PRINT A NEWLINE
	ISZ PUTMSG	/INCREMENT RETURN ADDR
	JMP I PUTMSG	/RETURN

/PRINT A MESSAGE FOLLOWED BY AN OCTAL NUMBER
/PARAM[CALL+1]	MESSAGE INDEX
/PARAM[AC]	OCTAL VALUE
PMSITM,	0		/OCT VALUE TMP
PUTMSI,	0
	DCA PMSITM	/SAVE OCT VAL
	TAD I PUTMSI	/GET STR ADDR
	CDF STRDF	/SWITCH TO STR DATA FIELD
	JMS PUTSTR	/PRINT STRING
	CDF DEFDF	/SWITCH BACK TO DEF DF
	TAD PMSITM	/LOAD OCT VALUE
	JMS PUTOCT	/PRINT IT
	JMS PUTNL	/PRINT A NEWLINE
	ISZ PUTMSI	/INCREMENT RETURN ADDR
	JMP I PUTMSI	/RETURN

/PRINT A MESSAGE STRING FOLLOWED BY ANOTHER STRING
/PARAM[CALL+1]	MESSAGE STRING
/PARAM[AC]	STRING
PMSSTM,	0		/STR VALUE TMP
PUTMSS,	0
	DCA PMSSTM	/SAVE STRING
	TAD I PUTMSS	/GET MSG STR ADDR
	CDF STRDF	/SWITCH TO STR DATA FIELD
	JMS PUTSTR	/PRINT MSG STRING
	CDF DEFDF	/SWITCH BACK TO DEF DF
	TAD PMSSTM	/LOAD SECOND STR
	JMS PUTSTR	/PRINT SECOND STRING
	JMS PUTNL	/PRINT NEWLINE
	ISZ PUTMSS	/INCREMENT RETURN ADDR
	JMP I PUTMSS	/RETURN

/PRINT DHRYSTONE RECORD CONTENTS
/PARAM[AC]	RECORD ADDRESS
PRECRC=11		/RECORD ADDRESS
PUTREC,	0
	TAD (-1
	DCA PRECRC	/PUT REC ADDR IN AUTOIDX
	TAD I PRECRC	/PTR_COMP MSG
	JMS PUTMSI
	PRCPTR
	TAD I PRECRC	/DISCR MSG
	JMS PUTMSI
	PRDISC
	TAD I PRECRC	/ENUM_COMP MSG
	JMS PUTMSI
	PRCENM
	TAD I PRECRC	/INT_COMP MSG
	JMS PUTMSI
	PRCINT
	TAD PRECRC	/STR_COMP MSG
	IAC
	JMS PUTMSS
	PRCSTR
	JMP I PUTREC	/RETURN
/THIS PAGE CONTAINS:
/PROC2, PROC4, PROC5
/PROC7, & PROC8
PAGE

/DHRYSTONE PROC_2 FUNCTION
/PARAM[AC]	INT ADDRESS
P2INTP=1		/INT ADDRESS
PROC2,	0
	DCA P2INTP	/SAVE ADDR
	TAD GCH1	/CHECK GCH1=='A'
	TAD (-1
	SZA CLA
	JMP P2END	/JUMP TO END IF NOT
	TAD GINT	/*PINT=*PINT+10-1-GINT
	CIA		/OR *PINT=*PINT+9-GINT
	TAD (11
	TAD I P2INTP
	DCA I P2INTP
P2END,	JMP I PROC2

/DHRYSTONE PROC_4 FUNCTION
PROC4,	0
	CLA
	TAD (-1		/CHECK IF GCH1 IS 'A' (1)
	TAD GCH1
	SNA CLA		/AC = GBOOL == 'A'
	IAC		/SET TRUE
	MQL		/OR LBOOL WITH GBOOL USING MQ
	TAD GBOOL
	MQA
	DCA GBOOL	/SAVE RESULT BACK TO GBOOL
	TAD (2		/SET GCH2 TO 'B' (2)
	DCA GCH2
	JMP I PROC4	/RETURN

/DHRYSTONE PROC_5 FUNCTION
PROC5,	0
	CLA
	TAD (1		/SET GCH1 TO 'A' (1)
	DCA GCH1
	DCA GBOOL
	JMP I PROC5	/RETURN

/DHRYSTONE PROC_7 FUNCTION
/PARAM[AC]	INT1
/PARAM[1]	INT2
/PARAM[2]	INTPTR
PROC7,	0
	TAD (2		/ADD 2 TO INT1 TO GET INTLOC
	TAD 1		/ADD INT2
	DCA I 2		/SAVE RESULT TO INTPTR
	JMP I PROC7

/DHRYSTONE PROC_8 FUNCTION
/PARAM[AC]	INT1
/PARAM[1]	INT2
/PARAM[2]	50 ARRAY ADDR
/PARAM[3]	50X50 ARRAY ADDR
P8INT2=1		/INT2 PARAM
P8ARR1=2		/ARRAY1 PARAM
P8ARR2=3		/ARRAY2 PARAM
P8LINT=4		/LOCAL INT
P8TMP1=6		/TEMP STORAGE 1
PROC8,	0
	TAD (5		/ADD 5 TO INT1 FOR LINT
	MQL
	MQA
	DCA P8LINT	/SAVE TO SCRATCH 4
	MQA		/GET ADDR OF ARR1[LINT]
	TAD P8ARR1
	DCA P8ARR1	/OVERWRITE ARR1 ADDR
	TAD P8INT2	/SAVE INT2 TO ARR1
	DCA I P8ARR1
	ISZ P8ARR1	/ARR1[LINT+1] TOO
	TAD P8INT2
	DCA I P8ARR1	/SAVE ARR1[LINT+1]=ARR1[LINT]
	TAD P8ARR1	/GET ADDR OF ARR1[30]
	TAD (35
	DCA P8ARR1
	MQA		/SET TO LINT
	DCA I P8ARR1
	MUY		/CALC ARR2[LINT] OFFSET
	ARRDIM
	CLA MQA		/ADD ARR2 BASE TO OFFSET
	TAD P8LINT	/ADD LINT FOR ARR2[LINT][LINT]
	TAD P8ARR2
	DCA P8TMP1	/PUT IN TMP1
	TAD P8LINT	/STORE LINT AT ARR2[LINT][LINT]
	DCA I P8TMP1
	ISZ P8TMP1
	TAD P8LINT	/AND ARR2[LINT][LINT+1]
	DCA I P8TMP1
	TAD P8TMP1	/INCREMENT ARR2[LINT][LINT-1]
	TAD (-2		/SUB 2 FROM ARR2[LINT][LINT+1]
	DCA P8TMP1
	ISZ I P8TMP1	/INCREMENT BY ONE
	TAD P8TMP1
	TAD (ARRDIM^20+1
	DCA P8TMP1
	TAD P8INT2	/ARR1[LINT] IS INT2
	DCA I P8TMP1	/SAVE TO ARR2[LINT+20][LINT]
	TAD (5		/SET GINT TO 5
	DCA GINT
	JMP I PROC8	/RETURN
/THIS PAGE CONTAINS:
/FUNC1, FUNC3, PROC3, PROC6
PAGE

/DHRYSTONE FUNC_1 FUNCTION
/PARAM[AC]	CHAR1
/PARAM[1]	CHAR2
/RESULT[AC]	ENUM VALUE
F1CH2=1		/CHAR2 PARAM
FUNC1,	0
	MQL		/SAVE CHAR1
	MQA
	CIA 		/CHECK CHAR1!=CHAR2
	TAD F1CH2
	SZA CLA		/RETURN IDENT1 IF NOT
	JMP I FUNC1
	MQA		/OTHERWISE, SET GCH1=CHAR1
	DCA GCH1	/AND RETURN IDENT2
	TAD IDENT2
	JMP I FUNC1	/RETURN

/DHRYSTONE FUNC_3 FUNCTION
/PARAM[AC]	ENUM VALUE
/RESULT[AC]	BOOL VALUE
F3LENM=1		/LOCAL ENUM
FUNC3,	0
	DCA F3LENM	/SAVE TO LOCAL VAL
	TAD (-IDENT3	/CHECK IF LENM==IDENT3
	TAD F3LENM
	SNA		/RETURN FALSE IF NOT
	JMP F3REF
	CLA		/SET AC TO FALSE (0)
	JMP I FUNC3
F3REF,	IAC		/SET AC TO TRUE (1)
	JMP I FUNC3

/DHRYSTONE PROC_3 FUNCTION
/PARAM[AC]	RECORD PTR ADDRESS
PROC3,	0
	DCA 1		/SAVE TO SCRATCH
	TAD GPTR	/CHECK IF GPTR IS NULL
	SNA CLA
	JMP P3CP7	/GO DIRECTLY TO P7 CALL
	TAD I GPTR	/GET GPTR->PTR_COMP
	DCA I 1		/ASSIGN TO PROVIDED PTR
P3CP7,	TAD GINT	/PLACE GINT IN PARAM[1]
	DCA 1
	TAD GPTR	/PLACE GPTR->VAR1.INT_COMP
	TAD (3		/ADDR IN PARAM[2]
	DCA 2
	TAD (12		/PLACE 10 IN PARAM[AC]
	JMS PROC7	/CALL PROC7
	JMP I PROC3	/RETURN

/DHRYSTONE PROC_6 FUNCTION
/PARAM[AC]	ENUM VALUE
/PARAM[1]	ENUM ADDRESS
P6ENAD,	0		/ENUM ADDRESS PARAM
P6ENVL,	0		/ENUM VALUE PARAM
PROC6,	0
	DCA P6ENVL	/SAVE ENUM VAL
	TAD 1		/SAVE ENUM ADDR
	DCA P6ENAD
	TAD P6ENVL	/STORE ENUM VAL AT ADDR
	DCA I P6ENAD
	TAD P6ENVL	/PLACE ENUM VAL IN PAR[AC]
	JMS FUNC3	/CALL FUNC3
	SZA		/SET ENUM ADDR TO IDENT4
	JMP P6F3FL	/IF FUNC3 RET FALSE
	TAD IDENT4
	DCA I P6ENAD
P6F3FL,	TAD P6JTBI	/GENERATE JUMP TABLE
	TAD P6ENVL	/ENTRY JMP INSTRUCTION
	DCA .+1		/STORE AT NEXT ADDRESS
	0000		/WILL BECOME A JMP INTO JTBL
P6JTBI,	JMP P6JTBL	/JUMP TABLE
P6JTBL,	JMP P6CSI1	/IDENT1
	JMP P6CSI2	/IDENT2
	JMP P6CSI3	/IDENT3
	JMP P6CSI4	/IDENT4
	JMP P6CSI5	/IDENT5
/P6CSI1,	TAD IDENT1	/CASE: IDENT1
P6CSI1,	JMP P6CSEN	/STORE ENM VAL TO ADDR
			/JUMP TO SWITCH END
P6CSI2,	TAD (-144	/CASE: IDENT2
	TAD GINT	/CHECK GINT > 100
	SPA CLA
	TAD IDENT4	/NO, SET IDENT4
	JMP P6CSEN	/JUMP TO END
P6CSI3,	TAD IDENT2	/CASE: IDENT3; ADR->IDENT2
	JMP P6CSEN	/JUMP TO END
P6CSI4,	TAD I P6ENAD	/CASE: IDENT4; KEEP CURR VAL
	JMP P6CSEN	/JUMP TO END
P6CSI5,	TAD IDENT3	/CASE: IDENT5; ADR->IDENT3
P6CSEN,	DCA I P6ENAD	/SAVE VALUE TO ADDR
	JMP I PROC6	/RETURN

/THIS PAGE CONTAINS
/PROC1

PAGE

/DHRYSTON PROC_1 FUNCTION
/PARAM[AC]	RECORD PTR
P1PTR,	0		/FIRST RECORD ADDRESS
P1NR,	0		/NEXT RECORD ADDRESS
P1PCI,	0		/REC->INT_COMP ADDR
P1NPCI,	0		/NEXT_REC->INT_COMP ADDR
PROC1,	0
	DCA P1PTR
	TAD I P1PTR	/LOAD RECORD->PTR_COMP
	DCA P1NR	/SAVE IT
	TAD GPTR	/SET GPTR AS MEMCPY SRC (MQ)
	MQL
	TAD (RECSZ	/SET MEMCPY LEN/PAR[1]
	DCA 1
	TAD P1NR	/SET NEXT REC AS DST (AC)
	JMS MEMCPY	/CALL MEMCPY
	TAD P1PTR	/GET ADR OF PTR->INT_COMP
	TAD (3
	DCA P1PCI	/SAVE TO PTR->INT_COMP ADDR
	TAD (5		/WRITE 5 TO PTR->INT_COMP
	DCA I P1PCI
	TAD P1NR	/NR->INT_COMP = PTR->INT_COMP
	TAD (3
	DCA P1NPCI
	TAD (5
	DCA I P1NPCI
	TAD P1NR	/NR->PTR_COMP = PTR->PTR_COMP
	DCA I P1NR
	TAD P1NR	/CALL PROC3 W/ ADDR OF
	JMS PROC3	/NR->PTR_COMP
	ISZ P1NR	/CHECK NR->DISCR==IDENT1
	TAD I P1NR	/LOAD NR->DISCR
	SZA CLA		/CHECK IF IDENT1 (0)
	JMP P1DNEQ
	TAD (6
	DCA I P1NPCI
	TAD P1NR	/SET PARAM[1]=
	IAC		/ADR(NR->ENUM_COMP)
	DCA 1
	TAD P1PTR	/SET AC=PTR->ENUM_COMP
	TAD (2
	DCA 2
	TAD I 2
	JMS PROC6	/CALL PROC6
	TAD P1NR
	TAD (-1
	DCA 1
	TAD I GPTR	/SET NR->PTR_COMP=
	DCA I 1		/GPTR->PTR_COM
	TAD P1NPCI	/SET PARAM[2]=
	DCA 2		/ADR(NR->INT_COMP)
	TAD (12		/SET PARAM[1]=10
	DCA 1
	TAD I P1NPCI	/PARAM[AC]=NR->INT_COMP
	JMS PROC7	/CALL PROC7
	JMP I PROC1	/RETURN
P1DNEQ,	TAD I P1PTR	/SET SRC TO PTR->NEXT
	MQL
	TAD (RECSZ	/SET SIZE TO REC SIZE
	DCA 1
	TAD P1PTR	/SET DST TO PTR
	JMS MEMCPY	/CALL MEMCPY
	JMP I PROC1	/RETURN

/THIS PAGE CONTAINS:
/GETCHR, FUNC2

PAGE

/GET CHAR AT INDEX N IN A STRING
/PARAM[AC]	STRING
/PARAM[1]	INDEX
/RESULT[AC]		CHAR AT INDEX IN STR
GCHIDX=1		/CHAR IDX IN STRING
GCHSTR=2		/STRING ADDRESS
GETCHR,	0
	DCA GCHSTR	/SAVE STRING
	TAD GCHIDX	/CUT IDX IN HALF
	CLL RAR
	TAD GCHSTR	/ADD TO STR
	DCA GCHSTR
	IAC		/IS IDX ODD?
	AND GCHIDX
	SNA
	JMP GCHEVN	/NO
	TAD I GCHSTR	/YES; GET STRING
	JMP GCHEND	/JUMP TO END
GCHEVN,	TAD I GCHSTR	/NO; GET STRING
	RTR;RTR;RTR	/ROTATE FOR 1ST HALF
GCHEND,	AND (77		/ONLY WANT 2ND HALF
	JMP I GETCHR	/RETURN

/DHRYSTONE FUNC_2 FUNCTION
/PARAM[AC]	FIRST STRING PTR
/PARAM[MQ]	SECOND STRING PTR
/RESULT[AC]	BOOL VALUE
F2STR1,	0		/FIRST STRING PARAM
F2STR2,	0		/SECOND STRING PARAM
F2LINT,	0		/LOCAL INT
F2LCH,	0		/LOCAL CHAR
F2TMP,	0		/TEMP STORAGE
FUNC2,	0
	DCA F2STR1	/SAVE BOTH STRINGS
	MQA
	DCA F2STR2
	IAC;IAC		/SET LINT TO 2
	DCA F2LINT
F2LOOP,	CLA
	TAD F2LINT	/CHECK LINT<=2
	TAD (-2
	SMA SZA		/BREAK IF NOT
	JMP F2LPEN
	TAD F2LINT	/SET INDEX TO LINT
	DCA 1
	TAD F2STR1	/SET STR TO STR1
	JMS GETCHR	/CALL GETCHR
	DCA F2TMP	/SAVE RESULT TO TMP
	TAD F2LINT	/SET INDEX TO LINT+1
	IAC
	DCA 1
	TAD F2STR2	/SET STRING TO STR2
	JMS GETCHR	/CALL GETCHR
	DCA 1		/PLACE RESULT IN PARAM[1]
	TAD F2TMP	/GET LAST RESULT AS PARAM[AC]
	JMS FUNC1	/CALL FUNC1
	SZA		/IF RES!=IDENT1 (0), LOOP BACK
	JMP F2LOOP
	CLA IAC		/SET LCH TO 1
	DCA F2LCH
	ISZ F2LINT	/INCREMENT LINT
	JMP F2LOOP	/LOOP BACK AROUND
F2LPEN,	CLA
	TAD F2LCH	/CHECK LCH>='W'&&LCH<'Z'
	TAD (-27	/LCH>='W' -> LCH-'W' IS POS
	MQL		/SAVE RESULT IN MQ
	TAD F2LCH	/LCH<'Z' -> 'Z-1'-LCH IS POS
	CIA		/NEGATE LCH
	TAD (31
	MQA		/OR RESULTS TOGETHER
	SPA		/IF POSITIVE, CHECK IS TRUE
	JMP F2WZFL	/SKIP OP IF <0
	CLA
	TAD (7		/SET LINT TO 7
	DCA F2LINT
F2WZFL,	CLA
	TAD (-22	/CHECK LCH=='R'
	TAD F2LCH
	SNA
	JMP F2RT	/JUMP TO RET TRUE IF YES
	CLA
	TAD F2STR2	/LOAD STR2 AS STR2
	DCA 1
	TAD F2STR1	/LOAD STR1 AS STR1
	JMS STRCMP	/CALL STRCMP
	SPA		/RET FALSE ON AC<=0
	JMP F2RF
	TAD F2LINT	/ADD 7 TO LINT
	TAD (7
	DCA F2LINT
	TAD F2LINT	/SET GINT TO LINT
	DCA GINT
F2RT,	CLA IAC		/SET AC TO 1
	JMP I FUNC2	/RETURN
F2RF,	CLA
	JMP I FUNC2

/FIELD 0 "HEAP" VARIABLES

PAGE

/RECORD STRUCT DATA
GREC,	GNREC	/PTR_COMP
	ID1	/DISCR
	ID3	/ENUM_COMP
	50	/INT_COMP == 40
		/STR_2_COMP
	TEXT \DHRYSTONE PROGRAM, SOME STRING\

GNREC,	ZBLOCK RECSZ

/MAIN FUNCTION LOCAL STRINGS
		/LEN IS STRSZ
MSTR1,	TEXT \DHRYSTONE PROGRAM, 1'ST STRING\
MSTR2,	ZBLOCK STRSZ

/GLOBAL ARRAYS
GARR,	ZBLOCK ARRDIM	/50 LENGTH ARRAY
			/50 BY 50 ARRAY/MATRIX
GARR2,	ZBLOCK ARRDIM^ARRDIM
TESTDA,	0

/STRING DATA FIELD
FIELD STRDF%10

PAGE

/BEGIN STRINGS
PRSTRT,	TEXT \DHRYSTONE BENCHMARK FOR PDP-12\
PRRCT,	TEXT \ROUND COUNT: \

/RESULT STRINGS
PREND,	TEXT \EXECUTION ENDS\
PRTIME,	TEXT \TIMER (100HZ):         \
PRGINT,	TEXT \INT_GLOB (GINT):       \
PRGBOO,	TEXT \BOOL_GLOB (BOOL):      \
PRGCH1,	TEXT \CH_1_GLOB (GCH1):      \
PRGCH2, TEXT \CH_2_GLOB (GCH2):      \
PRARR1,	TEXT \ARR_1_GLOB (ARR1):     \
PRARR2, TEXT \ARR_2_GLOB (ARR2):     \
PRPTR,	TEXT \PTR_GLOB (GPTR):       \
PRNPTR,	TEXT \NEXT_PTR_GLOB (NGPTR): \
PRCPTR,	TEXT \  PTR_COMP:            \
PRDISC, TEXT \  DISCR:               \
PRCENM, TEXT \  ENUM_COMP:           \
PRCINT, TEXT \  INT_COMP:            \
PRCSTR,	TEXT \  STR_COMP:            \
PRLIT1,	TEXT \INT_1_LOC (MINT1):     \
PRLIT2, TEXT \INT_2_LOC (MINT2):     \
PRLIT3,	TEXT \INT_3_LOC (MINT3):     \
PRLENM,	TEXT \ENUM_LOC (MENUM):      \
PRLST1,	TEXT \STR_1_LOC (MSTR1):     \
PRLST2,	TEXT \STR_2_LOC (MSTR2):     \
