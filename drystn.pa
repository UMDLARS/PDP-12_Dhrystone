/PDP-12 DHRYSTONE BY ZACHARY KIRTZ
/BASED ON DHRYSTONE BY REINHOLD P. WEICKER

/EAE INSTRUCTIONS
MUY=7405
DIV=7407
SHL=7413

/MISC DEFS
RECSZ=25	/RECORD STRUCT SIZE
STRSZ=21	/STR_30 SIZE

*20
/FIELD 0 GLOBAL VARIABLES
GINT,	0	/INT_GLOB
GBOOL,	0	/BOOL_GLOB
GCH1,	0	/CH_1_GLOB
GCH2,	0	/CH_2_GLOB

/GLOBAL VARIABLE ADDRESSES
GPTR,	GREC	/PTR_GLOB
GNPTR,	GNREC	/NEXT_PTR_GLOB
KGINT,	GINT
KGBOOL,	GBOOL
KGCH1,	GCH1
KGCH2,	GCH2
KGARR,	GARR
KGARR2,	GARR2

/GLOBAL CONSTANTS
IDENT1,	0
IDENT2,	1
IDENT3,	2
IDENT4,	3
IDENT5,	4
RUNCNT,	400	/RUN COUNT

/MAIN LOCAL VARIABLES
/PUTTING THESE IN PZ AT LEAST FOR NOW SINCE
/IT MAKES MY LIFE EASIER, WE HAVE SPACE, AND
/IT SHOULDN'T IMPACT PERFORMANCE
MINT1,	0	/INT_1_LOC
MINT2,	0	/INT_2_LOC
MINT3,	0	/INT_3_LOC
MCIDX,	0	/CH_INDEX
MENUM,	0	/ENUM_LOC
MRIDX,	0	/RUN_INDEX
KMSTR1,	MSTR1	/STR_1_LOC PTR
KMSTR2,	MSTR2	/STR_2_LOC PTR
PAGE

/INIT
	TAD KTEXTS
	JMS PUTSTR
	JMS PUTNL
	CLA
	TAD (1234
	JMS PUTOCT
	JMS PUTNL
	JMP I KEXIT

TEXTST,	TEXT \(TESTSTRING!123456HELLO:)\
KTEXTS,	TEXTST

KEXIT,	7600

/THIS PAGE CONTAINS:
/CHRCMP, STRCMP
/MEMCPY, STRCPY
PAGE

/CHARACTER COMPARE FUNCTION
/PARAM[AC]	FIRST CHAR
/PARAM[MQ]	SECOND CHAR
CHRCMP,	0
	AND (77		/ONLY WANT 2ND HALF
	DCA 1		/STORE IN SCRATCH
	MQA		/LOAD 2ND CHR INTO AC
	AND (77		/ONLY WANT 2ND HALF
	CIA		/NEGATE 2ND CHR
	TAD 1		/SUB 2ND FROM 1ST
	JMP I CHRCMP

/STRING COMPARE FUNCTION
/PARAM[AC]	FIRST STRING
/PARAM[1]	SECOND STRING
SCMPS1=2
SCMPS2=1
STRCMP,	0
	DCA SCMPS1	/STORE 1ST TO SCRATCH
SCMPLP,	TAD I SCMPS2	/LOAD 1ST HALF OF 2ND STR
	RTR;RTR;RTR
	MQL
	TAD I SCMPS1	/LOAD 1ST HALF OF 1ST STR
	RTR;RTR;RTR
	JMS CHRCMP	/COMPARE CHARS
	SZA		/RETURN IF DIFF
	JMP I STRCMP
	TAD I SCMPS2	/LOAD 2ND HALF OF 2ND STR
	MQL
	TAD I SCMPS1	/LOAD 2ND HALF OF 1ST STR
	JMS CHRCMP	/COMPARE CHARS
	SZA		/RETURN IF DIFF
	JMP I STRCMP
	MQL MQA		/CHECK IF 2ND HALF IS ZERO
	SNA		/RETURN IF IT IS
	JMP SCMPRE
	ISZ SCMPS1	/INCREMENT STR PTRS
	ISZ SCMPS2
	JMP SCMPLP	/LOOP BACK
SCMPRE,	CLA MQA		/COPY CMP RES BACK TO AC
	JMP I STRCMP

/STRING COPY FUNCTION
/PARAM[AC]	DST
/PARAM[MQ]	SRC
STRCPY,	0
	TAD (-1		/SUB 1 FROM EACH
	DCA 10		/AND PUT IN AUTOIDX
	MQA
	TAD (-1
	DCA 11
SCPYLP,	TAD I 11	/LOAD A WORD
	MQL		/SAVE FOR LATER
	DCA I 10	/SAVE AT DST
	MQA
	AND (77		/CHECK IF 2ND HALF IS ZERO
	SNA		/RETURN IF IT IS
	JMP I STRCPY
	JMP SCPYLP	/OTHERWISE, LOOP AGAIN

/MEMORY COPY FUNCTION
/PARAM[AC]	DST
/PARAM[MQ]	SRC
/PARAM[1]	LENGTH
MCPYLN=1
MCPYDS=10
MCPYSR=11
MEMCPY,	0
	TAD (-1		/SUB 1 FROM EACH
	DCA MCPYDS	/AND PUT IN AUTOIDX
	MQA
	TAD (-1
	DCA MCPYSR
	TAD MCPYLN	/NEGATE LENGTH, SUB 1
	CMA
	DCA MCPYLN
MCPYLP,	ISZ MCPYLN	/INC COUNT, CHECK IF DONE
	JMP .+2		/SKIP RETURN
	JMP I MEMCPY	/RETURN
	TAD I MCPYSR	/READ A WORD
	DCA I MCPYDS	/SAVE TO DST
	JMP MCPYLP	/LOOP BACK AROUND

/THIS PAGE CONTAINS:
/PUTC, PUTCHR, PUTSTR
/PUTOCT, PUTNL, PUTMSG, PUTMSI

PAGE

/PRINT CHAR IMPLEMENTATION
/PARAM[AC]	CHAR
PUTC,	0
	TLS		/SEND CHAR
	TSF		/WAIT FOR PRINT FINISH
	JMP .-1
	JMP I PUTC	/RETURN

/PRINT CHARACTER FUNCTION
/PARAM[AC]	CHARACTER
PUTCHR,	0
	AND (77		/ONLY WANT 1ST HALF
	SNA		/RETURN IF ZERO
	JMP I PUTCHR
	TAD (-40	/CONVERT FROM 6BIT
	SPA		/ASCII TO 8BIT ASCII
	TAD (100	/(ALPHA CHAR)
	TAD (240
	JMS PUTC	/ACTUALLY SEND CHAR
	JMP I PUTCHR

/PRINT STRING FUNCTION
/PARAM[AC]	STRING ADDRESS
PUTSTR,	0
	TAD (-1		/PLACE ADDR-1 IN AUTOIDX
	DCA 10
PSTRLP,	TAD I 10	/GET CHAR
	MQL		/SAVE FOR LATER
	MQA
	RTR;RTR;RTR	/GET FIRST HALF
	JMS PUTCHR	/PRINT CHR
	SNA		/RETURN IF ZERO
	JMP I PUTSTR	/(NULL CHR WAS PROVIDED)
	CLA MQA		/GET 2ND HALF
	JMS PUTCHR	/PRINT CHR
	SNA		/RETURN IF ZERO
	JMP I PUTSTR
	CLA		/CLEAR AC FOR NEXT LOOP
	JMP PSTRLP	/LOOP BACK AROUND

/PRINT OCTAL NUMBER
/PARAM[AC]	NUMBER TO PRINT
POCTCT,	0
PUTOCT,	0
	MQL		/PUT NUMBER IN MQ
	TAD (-4		/SET COUNTER TO -4
	DCA POCTCT
POCTLP,	CLA SHL		/SHIFT NEXT BITS INTO AC
	0002
	TAD (60		/ADD '0' TO GET ASCII CHAR
	JMS PUTCHR	/PRINT CHAR
	ISZ POCTCT	/CHECK HOW MANY LEFT
	JMP POCTLP	/LOOP BACK AROUND
	JMP I PUTOCT	/RETURN

/SEND NEWLINE CHARACTER
PUTNL,	0
	TAD (215	/PRINT CR
	JMS PUTC
	CLA
	TAD (212	/SEND LF
	JMS PUTC
	JMP I PUTNL

/PRINT A MESSAGE FROM THE MESSAGE LIST
/PARAM[AC]	MESSAGE INDEX
KMSGLS,	MSGLST
PUTMSG,	0
	TAD KMSGLS	/GET ADDR OF STR PTR
	DCA 1		/STORE SO WE CAN INDIR READ
	TAD I 1		/READ STR PTR
	JMS PUTSTR	/PRINT STRING
	JMS PUTNL	/PRINT A NEWLINE
	JMP I PUTMSG	/RETURN

/PRINT A MESSAGE FROM MSG LIST FOLLOWED BY AN OCT VALUE
/PARAM[AC]	MESSAGE INDEX
/PARAM[MQ]	OCTAL VALUE
PMSITM,	0
PUTMSI,	0
	TAD KMSGLS	/GET ADDR OF STR PTR
	DCA 2		/STORE SO WE CAN INDIR READ
	MQA		/COPY OCT VAL TO LOCAL STORAGE
	DCA PMSITM
	TAD I 2		/READ STR PTR
	JMS PUTSTR	/PRINT STRING
	TAD PMSITM	/LOAD OCT VALUE
	JMS PUTOCT	/PRINT IT
	JMS PUTNL	/PRINT A NEWLINE
	JMP I PUTMSI	/RETURN
/THIS PAGE CONTAINS:
/PROC2, PROC4, PROC5
/PROC7, & PROC8
PAGE

/DHRYSTONE PROC_2 FUNCTION
/PARAM[AC]	INT ADDRESS
P2INTP=1
P2INT=2
P2ENM=3
PROC2,	0
	DCA P2INTP	/PLACE ADDR IN TEMP
	TAD I P2INTP	/GET *ADDR + 10
	TAD (12
	DCA P2INT
P2LOOP,	TAD GCH1	/CHECK IF GCH1 == 'A' (1)
	TAD (-1
	SNA
	JMP P2LPEN	/JUMP TO LOOP COND CHECK
	TAD P2INT	/SUBTRACT ONE FROM INT
	TAD (-1
	DCA P2INT
	TAD GINT	/LOAD AND NEGATE GLOBAL INT
	CIA
	TAD P2INT	/SUB GINT FROM INT
	DCA I P2INTP	/SAVE RESULT TO INT PTR
	TAD IDENT1	/SET ENUM TO IDENT1
	DCA P2ENM
P2LPEN,	TAD P2ENM	/CHECK IF ENUM IS IDENT1
	TAD IDENT1
	SNA
	JMP I PROC2	/RETURN IF IT IS
	JMP P2LOOP	/LOOP BACK AROUND
/PROC TEMP REGISTERS IN SCRATCH

/DHRYSTONE PROC_4 FUNCTION
PROC4,	0
	TAD (1	/CHECK IF GCH1 IS 'A' (1)
	CIA		/NEGATE 'A'
	TAD GCH1
	SNA		/AC = GBOOL == 'A'
	JMP P4EQA
	CLA		/CLEAR AC (FALSE)
	JMP .+1
P4EQA,	CLA IAC		/SET AC TO 1 (TRUE)
	MQL		/OR LBOOL WITH GBOOL USING MQ
	TAD GBOOL
	MQA
	DCA GBOOL	/SAVE RESULT BACK TO GBOOL
	TAD (2	/SET GCH2 TO 'B' (2
	DCA GCH2
	JMP I PROC4	/RETURN

/DHRYSTONE PROC_5 FUNCTION
PROC5,	0
	TAD (1	/SET GCH1 TO 'A' (1)
	DCA GCH1
	CLA		/SET GBOOL TO FALSE (0)
	DCA GBOOL
	JMP I PROC5	/RETURN

/DHRYSTONE PROC_7 FUNCTION
/PARAM[AC]	INT1
/PARAM[1]	INT2
/PARAM[2]	INTPTR
PROC7,	0
	TAD (2		/ADD 2 TO INT1 TO GET INTLOC
	TAD 1		/ADD INT2
	DCA 2		/SAVE RESULT TO INTPTR
	JMP I PROC7

/DHRYSTONE PROC_8 FUNCTION
/PARAM[AC]	INT1
/PARAM[1]	INT2
/PARAM[2]	50 ARRAY ADDR
/PARAM[3]	50X50 ARRAY ADDR
P8INT2=1
P8ARR1=2
P8ARR2=3
P8LINT=4
P8IDX=5
P8TMP1=6
P8TMP2=7
PROC8,	0
	TAD (5		/ADD 5 TO INT1 FOR INTLOC
	MQL
	MQA
	DCA P8LINT	/SAVE TO SCRATCH 4
	MQA		/SET LOC TO IDX
	DCA P8IDX
	MQA		/GET ADDR OF ARR1[LOC]
	TAD P8ARR1
	DCA P8TMP1
	TAD P8INT2	/SAVE INT2 TO ARR1
	DCA I P8TMP1
	TAD I P8TMP1	/RE-READ VALUE (COULD BE DCA1)
	ISZ P8TMP1	/INCREMENT ADDRESS (ARR1+LINT+1)
	DCA I P8TMP1	/SAVE ARR1[LINT+1]=ARR1[LINT]
	TAD P8TMP1	/GET ADDR OF ARR1[30]
	TAD (35
	DCA P8TMP1
	TAD P8LINT	/SET TO LOC
	DCA I P8TMP1
	TAD P8LINT	/SETUP LOOP END IDX
	IAC		/LOC + 1
	DCA P8TMP1	/USE TMP1 AS END IDX
	TAD P8LINT	/GET ADDR OF ARR1[LOC][0]
	MQL
	TAD (62
	DCA .+2
	MUY
	0		/MUY OPERAND
P8LOOP,	DCA P8LINT	/CHECK CURRENT LOOP IDX
	CIA		/SUBTRACT CUR IDX FROM END
	TAD P8TMP1
	SPA		/BREAK IF POSITIVE (END<=CURR)
	JMP P8LPEN
	CLA
	MQA		/GET ADDR ARR[LOC][0]
	TAD P8IDX	/ADD IDX FOR ARR[LOC][IDX]
	DCA P8TMP2
	TAD P8LINT	/SAVE LOC TO ARR[LOC][IDX]
	DCA I P8TMP2
	JMP P8LOOP
P8LPEN, CLA MQA		/GET ARR[LOC][IDX] ADDR
	TAD P8LINT
	TAD (-1
	DCA P8TMP2
	ISZ P8TMP2	/INCREMENT BY ONE
	TAD P8LINT	/LOC+20
	TAD (24
	MQL		/WILL BE USED FOR MULTIPLY
	TAD (62
	DCA .+2
	MUY
	0		/MULTIPLY OPERAND
	CLA MQA		/GET LOWER RESULT
	TAD P8LINT	/ARR2[LOC+20][LOC]
	DCA P8TMP1	/SAVE ADDR TO TMP1
	TAD P8ARR1	/GET ADDR OF ARR1[LOC]
	TAD P8LINT
	DCA I P8TMP1
	TAD (5		/SET GINT TO 5
	DCA GINT
	JMP I PROC8	/RETURN
/THIS PAGE CONTAINS:
/FUNC1, FUNC3, PROC3, PROC6
PAGE

/DHRYSTONE FUNC_1 FUNCTION
/PARAM[AC]	CHAR1
/PARAM[1]	CHAR2
F1CH2=1
F1LCH1=2
F1LCH2=3
FUNC1,	0
	DCA F1LCH1	/SET LCH1 TO CH1
	TAD F1LCH1	/SET SET LCH2 TO LCH1
	DCA F1LCH2
	TAD F1LCH2	/CHECK IF LCH2 == CH2
	CIA
	TAD F1CH2
	SZA		/RETURN IDENT1 IF NOT
	JMP F1REI1
	TAD F1LCH1	/SET GCH1 TO LCH1
	DCA GCH1
	TAD IDENT2	/RETURN IDENT2 IN AC
	JMP I FUNC1
F1REI1,	CLA		/RETURN IDENT1 IN AC
	/TAD IDENT1	/REDUNDANT B/C I1==0
	JMP I FUNC1

/DHRYSTONE FUNC_3 FUNCTION
/PARAM[AC]	ENUM VALUE
F3LENM=1
FUNC3,	0
	DCA F3LENM	/SAVE TO LOCAL VAL
	TAD (-IDENT3	/CHECK IF LENM==IDENT3
	TAD F3LENM
	SNA		/RETURN FALSE IF NOT
	JMP F3REF
	CLA		/SET AC TO FALSE (0)
	JMP I FUNC3
F3REF,	IAC		/SET AC TO TRUE (1)
	JMP I FUNC3

/DHRYSTONE PROC_3 FUNCTION
/PARAM[AC]	RECORD PTR ADDRESS
PROC3,	0
	DCA 1		/SAVE TO SCRATCH
	TAD GPTR	/CHECK IF GPTR IS NULL
	SNA
	JMP P3CP7	/GO DIRECTLY TO P7 CALL
	CLA
	TAD I GPTR	/GET GPTR->PTR_COMP
	DCA I 1		/ASSIGN TO PROVIDED PTR
P3CP7,	TAD GINT	/PLACE GINT IN PARAM[1]
	DCA 1
	TAD GPTR	/PLACE GPTR->VAR1.INT_COMP
	TAD (3		/ADDR IN PARAM[2]
	DCA 2
	TAD (12		/PLACE 10 IN PARAM[AC]
	JMS PROC7	/CALL PROC7
	JMP I PROC3	/RETURN

/DHRYSTONE PROC_6 FUNCTION
/PARAM[AC]	ENUM VALUE
/PARAM[1]	ENUM ADDRESS
P6ENAD,	0
P6ENVL,	0
PROC6,	0
	DCA P6ENVL	/SAVE ENUM VAL
	TAD 1		/SAVE ENUM ADDR
	DCA P6ENAD
	TAD P6ENVL	/STORE ENUM VAL AT ADDR
	DCA I P6ENAD
	TAD P6ENVL	/PLACE ENUM VAL IN PAR[AC]
	JMS FUNC3	/CALL FUNC3
	SZA		/SET ENUM ADDR TO IDENT4
	JMP P6F3FL	/IF FUNC3 RET FALSE
	TAD (IDENT4
	DCA I P6ENAD
P6F3FL,	TAD P6JTBI	/GENERATE JUMP TABLE
	TAD P6ENVL	/ENTRY JMP INSTRUCTION
	DCA .+1		/STORE AT NEXT ADDRESS
	0000		/WILL BECOME A JMP INTO JTBL
P6JTBI,	JMP P6JTBL	/JUMP TABLE
P6JTBL,	JMP P6CSI1	/IDENT1
	JMP P6CSI2	/IDENT2
	JMP P6CSI3	/IDENT3
	JMP P6CSI4	/IDENT4
	JMP P6CSI5	/IDENT5
P6CSI1,	TAD IDENT1	/CASE: IDENT1
	DCA I P6ENAD	/STORE ENM VAL TO ADDR
	JMP P6CSEN	/JUMP TO SWITCH END
P6CSI2,	TAD (-144	/CASE: IDENT2
	TAD GINT	/CHECK GINT > 100
	SPA
	JMP P6C2LE	/NO
	TAD IDENT1	/YES, SET ENM ADR -> IDENT1
P6C2EN,	DCA I P6ENAD
	JMP P6CSEN	/JUMP TO END
P6C2LE,	TAD IDENT4	/NO, SET ENM ADR -> IDENT4
	JMP P6C2EN	/JUMP TO COMMON END
P6CSI3,	TAD IDENT2	/CASE: IDENT3; ADR->IDENT2
	DCA I P6ENAD
	JMP P6CSEN	/JUMP TO END
P6CSI4,	JMP P6CSEN	/CASE: IDENT4; JMP TO END
P6CSI5,	TAD IDENT3	/CASE: IDENT5; ADR->IDENT3
	DCA I P6ENAD
	JMP P6CSEN
P6CSEN,	JMP I PROC6	/RETURN

/THIS PAGE CONTAINS
/PROC1

PAGE

/DHRYSTON PROC_1 FUNCTION
/PARAM[AC]	RECORD PTR
P1PTR,	0
P1NR,	0
PROC1,	0
	TAD I P1PTR	/LOAD RECORD->PTR_COMP
	DCA P1NR	/SAVE IT
	TAD GPTR	/SET GPTR AS MEMCPY SRC (MQ)
	MQL
	TAD (5		/SET MEMCPY LEN/PAR[1] TO 5
	DCA 1
	TAD P1NR	/SET NEXT REC AS DST (AC)
	JMS MEMCPY	/CALL MEMCPY
TAD P1PTR	/GET ADR OF PTR->INT_COMP
	TAD (3
	DCA 1		/SAVE TO SCRATCH 1
	TAD (5		/WRITE 5 TO PTR->INT_COMP
	DCA I 1
	TAD I 1		/NR->INT_COMP = PTR->INT_COMP
	DCA 2
	TAD P1NR
	TAD (3
	DCA 1
	TAD 2
	DCA I 1
	TAD I P1PTR	/NR->PTR_COMP = PTR->PTR_COMP
	DCA I P1NR
	TAD P1NR	/CALL PROC3 W/ ADDR OF
	JMS PROC3	/NR->PTR_COMP
	TAD P1NR	/CHECK NR->DISCR==IDENT1
	IAC
	DCA 1		/LOAD NR->DISCR
	TAD I 1
	SZA		/CHECK IF IDENT1 (0)
	JMP P1DNEQ
	TAD P1NR	/SET NR->INT_COMP=6
	TAD (3
	DCA 1
	TAD (6
	DCA I 1
	TAD P1NR	/SET PARAM[1]=
	TAD (2		/ADR(NR->ENUM_COMP)
	DCA 1
	TAD P1PTR	/SET AC=PTR->ENUM_COMP
	TAD (2
	DCA 2
	TAD I 2
	JMS PROC6	/CALL PROC6
	CLA
	TAD I GPTR	/SET NR->PTR_COMP=
	DCA I P1NR	/GPTR->PTR_COM
	TAD P1NR	/SET PARAM[2]=
	TAD (3		/ADR(NR->INT_COMP)
	DCA 2
	TAD (12		/SET PARAM[1]=10
	DCA 1
	TAD P1NR	/SET PARAM[AC]=
	TAD (3		/NR->INT_COMP
	DCA 3
	TAD I 3
	JMS PROC7	/CALL PROC7
	JMP I PROC1	/RETURN
P1DNEQ,	TAD I P1PTR	/SET SRC TO PTR->NEXT
	MQL
	TAD (RECSZ	/SET SIZE TO REC SIZE
	DCA 1
	TAD P1PTR	/SET DST TO PTR
	JMS MEMCPY	/CALL MEMCPY
	JMP I PROC1	/RETURN

/THIS PAGE CONTAINS:
/GETCHR, FUNC2

PAGE

/GET CHAR AT INDEX N IN A STRING
/PARAM[AC]	STRING
/PARAM[1]	INDEX
GCHIDX=1
GCHSTR=2
GETCHR,	0
	DCA GCHSTR	/SAVE STRING
	TAD GCHIDX	/CUT IDX IN HALF
	CLL RAR
	TAD GCHSTR	/ADD TO STR
	DCA GCHSTR
	IAC		/IS IDX ODD?
	AND GCHIDX
	SNA
	JMP GCHEVN	/NO
	TAD I GCHSTR	/YES; GET STRING
	JMP GCHEND	/JUMP TO END
GCHEVN,	TAD I GCHSTR	/NO; GET STRING
	RTR;RTR;RTR	/ROTATE FOR 1ST HALF
GCHEND,	AND (77		/ONLY WANT 2ND HALF
	JMP I GETCHR	/RETURN

/DHRYSTONE FUNC_2 FUNCTION
/PARAM[AC]	FIRST STRING PTR
/PARAM[MQ]	SECOND STRING PTR
F2STR1,	0
F2STR2,	0
F2LINT,	0
F2LCH,	0
F2TMP,	0
FUNC2,	0
	DCA F2STR1	/SAVE BOTH STRINGS
	MQA
	DCA F2STR2
	IAC;IAC		/SET LINT TO 2
	DCA F2LINT
F2LOOP,	TAD F2LINT	/CHECK LINT<=2
	TAD (-2
	SPA SNA		/BREAK IF NOT
	JMP F2LPEN
	TAD F2LINT	/SET INDEX TO LINT
	DCA 1
	TAD F2STR1	/SET STR TO STR1
	JMP GETCHR	/CALL GETCHR
	DCA F2TMP	/SAVE RESULT TO TMP
	TAD F2LINT	/SET INDEX TO LINT+1
	IAC
	DCA 1
	TAD F2STR2	/SET STRING TO STR2
	JMP GETCHR	/CALL GETCHR
	DCA 1		/PLACE RESULT IN PARAM[1]
	TAD F2TMP	/GET LAST RESULT AS PARAM[AC]
	JMP FUNC1	/CALL FUNC1
	SZA		/IF RES!=IDENT1 (0), LOOP BACK
	JMP F2LOOP
	CLA IAC		/SET LCH TO 1
	DCA F2LCH
	ISZ F2LINT	/INCREMENT LINT
	JMP F2LOOP	/LOOP BACK AROUND
F2LPEN,	TAD F2LCH	/CHECK LCH>='W'&&LCH<'Z'
	TAD (-27	/LCH>='W' -> LCH-'W' IS POS
	MQL		/SAVE RESULT IN MQ
	TAD F2LCH	/LCH<'Z' -> 'Z-1'-LCH IS POS
	CIA		/NEGATE LCH
	TAD (31
	MQA		/OR RESULTS TOGETHER
	SPA		/IF POSITIVE, CHECK IS TRUE
	JMP F2WZFL	/SKIP OP IF <0
	CLA
	TAD (7		/SET LINT TO 7
	DCA F2LINT
F2WZFL,	TAD (-22	/CHECK LCH=='R'
	TAD F2LCH
	SNA
	JMP F2RT	/JUMP TO RET TRUE IF YES
	TAD F2STR2	/LOAD STR2 AS STR2
	MQL
	TAD F2STR1	/LOAD STR1 AS STR1
	JMP STRCMP	/CALL STRCMP
	SPA		/RET FALSE ON AC<=0
	JMP F2RF
	TAD F2LINT	/ADD 7 TO LINT
	TAD (7
	DCA F2LINT
	TAD F2LINT	/SET GINT TO LINT
	DCA GINT
F2RT,	CLA IAC		/SET AC TO 1
	JMP I FUNC2	/RETURN
F2RF,	CLA
	JMP I FUNC2

/FIELD 0 "HEAP" VARIABLES

PAGE

/RECORD STRUCT DATA
GREC,	GNREC	/PTR_COMP
	IDENT1	/DISCR
	IDENT3	/ENUM_COMP
	50	/INT_COMP == 40
		/STR_2_COMP
	TEXT \DHRYSTONE PROGRAM, SOME STRING\

GNREC,	ZBLOCK RECSZ

/MAIN FUNCTION LOCAL STRINGS
		/LEN IS STRSZ
MSTR1,	TEXT \DHRYSTONE PROGRAM, 1'ST STRING\
MSTR2,	ZBLOCK STRSZ

/BEGIN STRINGS
PRSTRT,	TEXT \DHRYSTONE BENCHMARK FOR PDP-12\
PRRCT,	TEXT \ROUND COUNT: \

/RESULT STRINGS
PREND,	TEXT \EXECUTION ENDS\
PRGINT,	TEXT \INT_GLOB (GINT):       \
PRGBOO,	TEXT \BOOL_GLOB (BOOL):      \
PRGCH1,	TEXT \CH_1_GLOB (GCH1):      \
PRGCH2, TEXT \CH_2_GLOB (GCH2):      \
PRARR1,	TEXT \ARR_1_GLOB (ARR1):     \
PRARR2, TEXT \ARR_2_GLOB (ARR2):     \
PRPTR,	TEXT \PTR_GLOB (GPTR):       \
PRNPTR,	TEXT \NEXT_PTR_GLOB (NGPTR): \
PRCPTR,	TEXT \PTR_COMP:              \
PRDISC, TEXT \  DISCR:               \
PRCENM, TEXT \  ENUM_COMP:           \
PRCINT, TEXT \  INT_COMP:            \
PRCSTR,	TEXT \  STR_COMP:            \
PRLIT1,	TEXT \INT_1_LOC (MINT1):     \
PRLIT2, TEXT \INT_2_LOC (MINT2):     \
PRLIT3,	TEXT \INT_3_LOC (MINT3):     \
PRLENM,	TEXT \ENUM_LOC (MENUM):      \
PRLST1,	TEXT \STR_1_LOC (MSTR1):     \
PRLST2,	TEXT \STR_2_LOC (MSTR2):     \

/MESSAGE LIST
MSGLST,	PRSTRT	/0
	PRRCT	/1
	PREND	/2
	PRGINT	/3
	PRGBOO	/4
	PRGCH1	/5
	PRGCH2	/6
	PRARR1	/7
	PRARR2	/10
	PRPTR	/11
	PRNPTR	/12
	PRCPTR	/13
	PRDISC	/14
	PRCENM	/15
	PRCINT	/16
	PRCSTR	/17
	PRLIT1	/20
	PRLIT2	/21
	PRLIT3	/22
	PRLENM	/23
	PRLST1	/24
	PRLST2	/25
/PAGE START: DATA FIELD
FIELD 1

*20

/GLOBAL ARRAYS
DECIMAL
GARR,	ZBLOCK 50	/50 LENGTH ARRAY
GARR2,	ZBLOCK 50^50	/50 BY 50 ARRAY/MATRIX
OCTAL
