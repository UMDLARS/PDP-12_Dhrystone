/PDP-12 DHRYSTONE BY ZACHARY KIRTZ
/BASED ON DHRYSTONE BY REINHOLD P. WEICKER

/EAE INSTRUCTIONS
MUY=7405

/MISC DEFS
RECSZ=43	/RECORD STRUCT SIZE

*20
/FIELD 0 GLOBAL VARIABLES
GINT,	0
GBOOL,	0
GCH1,	0
GCH2,	0

/GLOBAL VARIABLE ADDRESSES
GPTR,	GREC
GNPTR,	GNREC
KGINT,	GINT
KGBOOL,	GBOOL
KGCH1,	GCH1
KGCH2,	GCH2
KGARR,	GARR
KGARR2,	GARR2

/GLOBAL CONSTANTS
IDENT1,	0
IDENT2,	1
IDENT3,	2
IDENT4,	3
IDENT5,	4

PAGE

/THIS PAGE CONTAINS:
/CHRCMP, STRCMP
/MEMCPY, STRCPY
/PUTCHR, PUTSTR, PUTOCT
PAGE

/CHARACTER COMPARE FUNCTION
/PARAM[AC]	FIRST CHAR
/PARAM[MQ]	SECOND CHAR
CHRCMP,	0
	AND (77		/ONLY WANT 2ND HALF
	DCA 1		/STORE IN SCRATCH
	MQA		/LOAD 2ND CHR INTO AC
	AND (77		/ONLY WANT 2ND HALF
	CIA		/NEGATE 2ND CHR
	TAD 1		/SUB 2ND FROM 1ST
	JMP CHRCMP

/STRING COMPARE FUNCTION
/PARAM[AC]	FIRST STRING
/PARAM[1]	SECOND STRING
STRCMP,	0
	DCA 2		/STORE 1ST TO SCRATCH
SCMPLP,	TAD I 1		/LOAD 1ST HALF OF 2ND STR
	RTR;RTR;RTR
	MQL
	TAD I 2		/LOAD 1ST HALF OF 1ST STR
	RTR;RTR;RTR
	JMS CHRCMP	/COMPARE CHARS
	SZA		/RETURN IF DIFF
	JMP STRCMP
	TAD I 1		/LOAD 2ND HALF OF 2ND STR
	MQL
	TAD I 2		/LOAD 2ND HALF OF 1ST STR
	JMS CHRCMP	/COMPARE CHARS
	SZA		/RETURN IF DIFF
	JMP STRCMP
	MQL MQA		/CHECK IF 2ND HALF IS ZERO
	SNA		/RETURN IF IT IS
	JMP SCMPRE
	ISZ 1		/INCREMENT STR PTRS
	ISZ 2
	JMP SCMPLP	/LOOP BACK
SCMPRE,	CLA MQA		/COPY CMP RES BACK TO AC
	JMP STRCMP

/STRING COPY FUNCTION
/PARAM[AC]	DST
/PARAM[MQ]	SRC
STRCPY,	0
	TAD (-1		/SUB 1 FROM EACH
	DCA 10		/AND PUT IN AUTOIDX
	MQA
	TAD (-1
	DCA 11
SCPYLP,	TAD I 11	/LOAD A WORD
	MQL		/SAVE FOR LATER
	DCA I 10	/SAVE AT DST
	MQA
	AND (77		/CHECK IF 2ND HALF IS ZERO
	SNA		/RETURN IF IT IS
	JMP STRCPY
	JMP SCPYLP	/OTHERWISE, LOOP AGAIN

/MEMORY COPY FUNCTION
/PARAM[AC]	DST
/PARAM[MQ]	SRC
/PARAM[1]	LENGTH
MEMCPY,	0
	TAD (-1		/SUB 1 FROM EACH
	DCA 10		/AND PUT IN AUTOIDX
	MQA
	TAD (-1
	DCA 11
	DCA 12		/CLEAR COUNTER
MCPYLP,	TAD 12		/CHECK IF WE'VE COPIED
	CIA		/ALL BY SUB COUNT FROM LEN
	TAD 1
	SPA		/RETURN IF RES IS NEGATIVE
	JMP MEMCPY
	TAD 11		/READ A WORD
	DCA 10		/SAVE TO DST

/PRINT CHARACTER FUNCTION
/PARAM[AC]	CHARACTER
PUTCHR,	0
	AND (77		/ONLY WANT 1ST HALF
	SZA		/RETURN IF ZERO
	JMP PUTCHR
	TAD (-40	/CONVERT FROM 6BIT
	SPA		/ASCII TO 8BIT ASCII
	TAD (100	/(ALPHA CHAR)
	TAD (240
	TSF		/WAIT FOR TTY PRINTER
	JMP .-1
	TLS		/SEND CHAR
	JMP PUTCHR

/PRINT STRING FUNCTION
/PARAM[AC]	STRING ADDRESS
PUTSTR,	0
	TAD (-1		/PLACE ADDR-1 IN AUTOIDX
	DCA 10
PSTRLP,	TAD I 10	/GET CHAR
	MQL		/SAVE FOR LATER
	RTR;RTR;RTR	/GET FIRST HALF
	JMS PUTCHR	/PRINT CHR
	SZA		/RETURN IF ZERO
	JMP PUTSTR	/(NULL CHR WAS PROVIDED)
	CLA MQA		/GET 2ND HALF
	JMS PUTCHR	/PRINT CHR
	SZA		/RETURN IF ZERO
	JMP PUTSTR
	JMP PSTRLP	/LOOP BACK AROUND

/PRINT OCTAL NUMBER
/PARAM[AC]	NUMBER TO PRINT
PUTOCT,	0
	RTL;RTL		/ROTATE 1ST SPOT INTO 4TH
	DCA POCTTM	/SAVE VALUE
	DCA 10		/CLEAR COUNTER
POCTLP,	TAD POCTTM	/LOAD VALUE
	AND (7		/ONLY WANT LAST PART
	TAD (60		/ADD '0' TO GET ASCII CHAR
	JMS PUTCHR	/PRINT CHAR
	TAD 10		/CHECK HOW MANY LEFT
	TAD (-4
	SNA		/RETURN IF NONE
	JMP PUTOCT
	TAD POCTTM	/ROTATE TO NEXT PART
	RTL;RAL
	DCA POCTTM
POCTTM, 0
/THIS PAGE CONTAINS:
/PROC2, PROC4, PROC5
/PROC7, & PROC8
PAGE

/DHRYSTONE PROC_2 FUNCTION
/PARAM[AC]	INT ADDRESS
PROC2,	0
	DCA P2INTP	/PLACE ADDR IN TEMP
	TAD I P2INTP	/GET *ADDR + 10
	TAD (12
	DCA P2INT
P2LOOP,	TAD GCH1	/CHECK IF GCH1 == 'A' (301)
	TAD (-301
	SNA
	JMP P2LPEN	/JUMP TO LOOP COND CHECK
	TAD P2INT	/SUBTRACT ONE FROM INT
	TAD (-1
	DCA P2INT
	TAD GINT	/LOAD AND NEGATE GLOBAL INT
	CIA
	TAD P2INT	/SUB GINT FROM INT
	DCA I P2INTP	/SAVE RESULT TO INT PTR
	TAD IDENT1	/SET ENUM TO IDENT1
	DCA P2ENM
P2LPEN,	TAD P2ENM	/CHECK IF ENUM IS IDENT1
	TAD IDENT1
	SNA
	JMP PROC2	/RETURN IF IT IS
	JMP P2LOOP	/LOOP BACK AROUND
/PROC TEMP REGISTERS IN SCRATCH
P2INTP=1
P2INT=2
P2ENM=3

/DHRYSTONE PROC_4 FUNCTION
PROC4,	0
	TAD (301	/CHECK IF GCH1 IS 'A' (301)
	CIA		/NEGATE 'A'
	TAD GCH1
	SNA		/AC = GBOOL == 'A'
	JMP P4EQA
	CLA		/CLEAR AC (FALSE)
	JMP .+1
P4EQA,	CLA IAC		/SET AC TO 1 (TRUE)
	MQL		/OR LBOOL WITH GBOOL USING MQ
	TAD GBOOL
	MQA
	DCA GBOOL	/SAVE RESULT BACK TO GBOOL
	TAD (302	/SET GCH2 TO 'B' (302
	DCA GCH2
	JMP PROC4	/RETURN

/DHRYSTONE PROC_5 FUNCTION
PROC5,	0
	TAD (301	/SET GCH1 TO 'A'
	DCA GCH1
	CLA		/SET GBOOL TO FALSE (0)
	DCA GBOOL
	JMP PROC5	/RETURN

/DHRYSTONE PROC_7 FUNCTION
/PARAM[AC]	INT1
/PARAM[1]	INT2
/PARAM[2]	INTPTR
PROC7,	0
	TAD (2		/ADD 2 TO INT1 TO GET INTLOC
	TAD 1		/ADD INT2
	DCA 2		/SAVE RESULT TO INTPTR
	JMP PROC7

/DHRYSTONE PROC_8 FUNCTION
/PARAM[AC]	INT1
/PARAM[1]	INT2
/PARAM[2]	50 ARRAY ADDR
/PARAM[3]	50X50 ARRAY ADDR
P8INT2=1
P8ARR1=2
P8ARR2=3
P8LINT=4
P8IDX=5
P8TMP1=6
P8TMP2=7
PROC8,	0
	TAD (5		/ADD 5 TO INT1 FOR INTLOC
	MQL
	MQA
	DCA P8LINT	/SAVE TO SCRATCH 4
	MQA		/SET LOC TO IDX
	DCA P8IDX
	MQA		/GET ADDR OF ARR1[LOC]
	TAD P8ARR1
	DCA P8TMP1
	TAD P8INT2	/SAVE INT2 TO ARR1
	DCA I P8TMP1
	TAD I P8TMP1	/RE-READ VALUE (COULD BE DCA1)
	ISZ P8TMP1	/INCREMENT ADDRESS (ARR1+LINT+1)
	DCA I P8TMP1	/SAVE ARR1[LINT+1]=ARR1[LINT]
	TAD P8TMP1	/GET ADDR OF ARR1[30]
	TAD (35
	DCA P8TMP1
	TAD P8LINT	/SET TO LOC
	DCA I P8TMP1
	TAD P8LINT	/SETUP LOOP END IDX
	IAC		/LOC + 1
	DCA P8TMP1	/USE TMP1 AS END IDX
	TAD P8LINT	/GET ADDR OF ARR1[LOC][0]
	MQL
	TAD (62
	DCA .+2
	MUY
	0		/MUY OPERAND
P8LOOP,	DCA P8LINT	/CHECK CURRENT LOOP IDX
	CIA		/SUBTRACT CUR IDX FROM END
	TAD P8TMP1
	SPA		/BREAK IF POSITIVE (END<=CURR)
	JMP P8LPEN
	CLA
	MQA		/GET ADDR ARR[LOC][0]
	TAD P8IDX	/ADD IDX FOR ARR[LOC][IDX]
	DCA P8TMP2
	TAD P8LINT	/SAVE LOC TO ARR[LOC][IDX]
	DCA I P8TMP2
	JMP P8LOOP
P8LPEN, CLA MQA		/GET ARR[LOC][IDX] ADDR
	TAD P8LINT
	TAD (-1
	DCA P8TMP2
	ISZ P8TMP2	/INCREMENT BY ONE
	TAD P8LINT	/LOC+20
	TAD (24
	MQL		/WILL BE USED FOR MULTIPLY
	TAD (62
	DCA .+2
	MUY
	0		/MULTIPLY OPERAND
	CLA MQA		/GET LOWER RESULT
	TAD P8LINT	/ARR2[LOC+20][LOC]
	DCA P8TMP1	/SAVE ADDR TO TMP1
	TAD P8ARR1	/GET ADDR OF ARR1[LOC]
	TAD P8LINT
	DCA I P8TMP1
	TAD (5		/SET GINT TO 5
	DCA GINT
	JMP PROC8	/RETURN
/THIS PAGE CONTAINS:
/FUNC1, FUNC3, PROC3, PROC6
PAGE

/DHRYSTONE FUNC_1 FUNCTION
/PARAM[AC]	CHAR1
/PARAM[1]	CHAR2
F1CH2=1
F1LCH1=2
F1LCH2=3
FUNC1,	0
	DCA F1LCH1	/SET LCH1 TO CH1
	TAD F1LCH1	/SET SET LCH2 TO LCH1
	DCA F1LCH2
	TAD F1LCH2	/CHECK IF LCH2 == CH2
	CIA
	TAD F1CH2
	SZA		/RETURN IDENT1 IF NOT
	JMP F1REI1
	TAD F1LCH1	/SET GCH1 TO LCH1
	DCA GCH1
	TAD IDENT2	/RETURN IDENT2 IN AC
	JMP FUNC1
F1REI1,	CLA		/RETURN IDENT1 IN AC
	/TAD IDENT1	/REDUNDANT B/C I1==0
	JMP FUNC1

/DHRYSTONE FUNC_3 FUNCTION
/PARAM[AC]	ENUM VALUE
F3LENM=1
FUNC3,	0
	DCA F3LENM	/SAVE TO LOCAL VAL
	TAD (-IDENT3	/CHECK IF LENM==IDENT3
	TAD F3LENM
	SNA		/RETURN FALSE IF NOT
	JMP F3REF
	CLA		/SET AC TO FALSE (0)
	JMP FUNC3
F3REF,	IAC		/SET AC TO TRUE (1)
	JMP FUNC3

/DHRYSTONE PROC_3 FUNCTION
/PARAM[AC]	RECORD PTR ADDRESS
PROC3,	0
	DCA 1		/SAVE TO SCRATCH
	TAD GPTR	/CHECK IF GPTR IS NULL
	SNA
	JMP P3CP7	/GO DIRECTLY TO P7 CALL
	CLA
	TAD I GPTR	/GET GPTR->PTR_COMP
	DCA I 1		/ASSIGN TO PROVIDED PTR
P3CP7,	TAD GINT	/PLACE GINT IN PARAM[1]
	DCA 1
	TAD GPTR	/PLACE GPTR->VAR1.INT_COMP
	TAD (3		/ADDR IN PARAM[2]
	DCA 2
	TAD (12		/PLACE 10 IN PARAM[AC]
	JMS PROC7	/CALL PROC7
	JMP PROC3	/RETURN

/DHRYSTONE PROC_6 FUNCTION
/PARAM[AC]	ENUM VALUE
/PARAM[1]	ENUM ADDRESS
P6ENAD,	0
P6ENVL,	0
PROC6,	0
	DCA P6ENVL	/SAVE ENUM VAL
	TAD 1		/SAVE ENUM ADDR
	DCA P6ENAD
	TAD P6ENVL	/STORE ENUM VAL AT ADDR
	DCA I P6ENAD
	TAD P6ENVL	/PLACE ENUM VAL IN PAR[AC]
	JMS FUNC3	/CALL FUNC3
	SZA		/SET ENUM ADDR TO IDENT4
	JMP P3F3FL	/IF FUNC3 RET FALSE
	TAD (IDENT4
	DCA I P6ENAD
P3F3FL,	TAD KP3JTB	/CALC ADDR IN JMP TABLE
	TAD P6ENVL
	DCA 1		/STORE IN SCRATCH 1
	JMP I 1		/JUMP INTO JUMP TABLE
KP3JTB,	P3JTBL		/JUMP TABLE
P3JTBL,	JMP P6CSI1	/IDENT1
	JMP P6CSI2	/IDENT2
	JMP P6CSI3	/IDENT3
	JMP P6CSI4	/IDENT4
	JMP P6CSI5	/IDENT5
P6CSI1,	TAD IDENT1	/CASE: IDENT1
	DCA I P6ENAD	/STORE ENM VAL TO ADDR
	JMP P6CSEN	/JUMP TO SWITCH END
P6CSI2,	TAD (-144	/CASE: IDENT2
	TAD GINT	/CHECK GINT > 100
	SPA
	JMP P6C2LE	/NO
	TAD IDENT1	/YES, SET ENM ADR -> IDENT1
P6C2EN,	DCA I P6ENAD
	JMP P6CSEN	/JUMP TO END
P6C2LE,	TAD IDENT4	/NO, SET ENM ADR -> IDENT4
	JMP P6C2EN	/JUMP TO COMMON END
P6CSI3,	TAD IDENT2	/CASE: IDENT3; ADR->IDENT2
	DCA I P6ENAD
	JMP P6CSEN	/JUMP TO END
P6CSI4,	JMP P6CSEN	/CASE: IDENT4; JMP TO END
P6CSI5,	TAD IDENT3	/CASE: IDENT5; ADR->IDENT3
	DCA I P6ENAD
	JMP P6CSEN
P6CSEN,	JMP PROC8	/RETURN

/THIS PAGE CONTAINS

PAGE

/DHRYSTON PROC_1 FUNCTION
/PARAM[AC]	RECORD PTR
PROC1,	0
	DCA P1PTR	/SAVE RECORD PTR
	TAD I P1PTR	/LOAD RECORD->PTR_COMP
	DCA P1NR	/SAVE IT
	TAD GPTR	/SET GPTR AS MEMCPY SRC (MQ)
	MQL
	TAD (5		/SET MEMCPY LEN/PAR[1] TO 5
	DCA 1
	TAD P1NR	/SET NEXT REC AS DST (AC)
	JMS MEMCPY	/CALL MEMCPY

P1NR,	0
/FIELD 0 "HEAP" VARIABLES

PAGE

/RECORD STRUCT DATA
GREC,	ZBLOCK RECSZ
GNREC,	ZBLOCK RECSZ

/PAGE START: DATA FIELD
FIELD 1

*20

/GLOBAL ARRAYS
DECIMAL
GARR,	ZBLOCK 50	/50 LENGTH ARRAY
GARR2,	ZBLOCK 50^50	/50 BY 50 ARRAY/MATRIX
OCTAL
